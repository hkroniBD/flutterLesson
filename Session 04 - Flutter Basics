### **Lecture Notes: Session 4 - Flutter Basics**

---

#### **1. Understanding Flutter Widgets**

**a. What are Widgets?**
- In Flutter, everything is a widget. Widgets are the building blocks of a Flutter app's user interface (UI). They describe what the UI should look like given its current configuration and state.

- **Types of Widgets:**
  - **Stateless Widgets:** These are immutable widgets that do not change once they are built. They are used for static content where the UI does not need to change over time.
  - **Stateful Widgets:** These widgets maintain state that can change during the widget's lifetime. The UI updates when the state changes.

**b. Importance of Widgets:**
- Widgets in Flutter represent both the UI components and their behavior. This unification of structure and logic makes Flutter apps easy to build and maintain.

- **Hierarchy:** Widgets are arranged in a hierarchy or tree structure. Each widget nests within its parent widget, creating a comprehensive UI tree known as the widget tree.

**c. Widget Composition:**
- **Composability:** Flutter encourages composing widgets instead of creating complex ones. Smaller widgets can be combined to create complex UI elements.

- **Example:**
  ```dart
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Flutter Basics')),
      body: Center(
        child: Column(
          children: <Widget>[
            Text('Hello, Flutter!'),
            Image.network('https://example.com/image.png'),
          ],
        ),
      ),
    );
  }
  ```

---

#### **2. StatelessWidget vs. StatefulWidget**

**a. StatelessWidget:**
- **Definition:** A `StatelessWidget` is a widget that does not have any mutable state. Once created, its properties do not change.
- **Lifecycle:** Stateless widgets are built only once. Any updates require the entire widget to be rebuilt.

- **Example:**
  ```dart
  class MyStatelessWidget extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
      return Text('I am a Stateless Widget');
    }
  }
  ```

- **Use Case:** Use `StatelessWidget` when the widget's UI depends only on the properties passed into it and not on dynamic data or state changes.

**b. StatefulWidget:**
- **Definition:** A `StatefulWidget` is a widget that can change its state over time. The state is maintained across rebuilds, and the UI updates when the state changes.

- **Components:**
  - **StatefulWidget Class:** This class itself is immutable and creates the `State` object.
  - **State Class:** This class contains the mutable state for the `StatefulWidget`. It manages the widget's data and handles rebuilding the UI when the state changes.

- **Example:**
  ```dart
  class MyStatefulWidget extends StatefulWidget {
    @override
    _MyStatefulWidgetState createState() => _MyStatefulWidgetState();
  }

  class _MyStatefulWidgetState extends State<MyStatefulWidget> {
    int _counter = 0;

    void _incrementCounter() {
      setState(() {
        _counter++;
      });
    }

    @override
    Widget build(BuildContext context) {
      return Column(
        children: <Widget>[
          Text('Counter: $_counter'),
          ElevatedButton(
            onPressed: _incrementCounter,
            child: Text('Increment'),
          ),
        ],
      );
    }
  }
  ```

- **Use Case:** Use `StatefulWidget` when the widget needs to react to user input, data changes, or any other event that requires updating the UI.

**c. Stateless vs. Stateful:**
- **StatelessWidget:** No state management, quick to rebuild, suitable for static content.
- **StatefulWidget:** Manages state, rebuilds when state changes, suitable for dynamic content.

---

#### **3. The Widget Tree and the build Method**

**a. The Widget Tree:**
- **Definition:** The widget tree is a hierarchical representation of all the widgets in a Flutter app. It defines how widgets are organized and rendered on the screen.
- **Structure:** The root of the widget tree is the `MaterialApp` or `CupertinoApp`, which contains the `Scaffold`, `AppBar`, and other UI elements.

**b. The build Method:**
- **Role:** The `build` method is responsible for creating a widget and defining how it should appear on the screen. This method is called whenever the widget needs to be rebuilt.

- **StatelessWidget:**
  ```dart
  class MyWidget extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
      return Text('This is a stateless widget');
    }
  }
  ```

- **StatefulWidget:**
  ```dart
  class MyStatefulWidget extends StatefulWidget {
    @override
    _MyStatefulWidgetState createState() => _MyStatefulWidgetState();
  }

  class _MyStatefulWidgetState extends State<MyStatefulWidget> {
    @override
    Widget build(BuildContext context) {
      return Text('This is a stateful widget');
    }
  }
  ```

**c. Rebuilding Widgets:**
- **StatelessWidget:** Rebuilt when its parent rebuilds.
- **StatefulWidget:** Rebuilt when `setState()` is called or when its parent rebuilds.

**d. Performance Considerations:**
- Minimize unnecessary rebuilds by keeping the widget tree as shallow as possible.
- Use keys to preserve the state of widgets during rebuilds.

---

#### **4. Introduction to Basic Widgets**

**a. Container:**
- **Definition:** A `Container` is a versatile widget that can contain a child widget and apply padding, margins, borders, and background color.
- **Example:**
  ```dart
  Container(
    padding: EdgeInsets.all(10.0),
    margin: EdgeInsets.all(10.0),
    decoration: BoxDecoration(
      color: Colors.blue,
      borderRadius: BorderRadius.circular(10.0),
    ),
    child: Text('Hello, Container!'),
  )
  ```

**b. Text:**
- **Definition:** The `Text` widget is used to display a string of text with customizable styles.
- **Example:**
  ```dart
  Text(
    'Hello, Flutter!',
    style: TextStyle(fontSize: 24, color: Colors.black),
  )
  ```

**c. Row:**
- **Definition:** The `Row` widget arranges its children in a horizontal sequence.
- **Example:**
  ```dart
  Row(
    mainAxisAlignment: MainAxisAlignment.center,
    children: <Widget>[
      Text('Row 1'),
      SizedBox(width: 10),
      Text('Row 2'),
    ],
  )
  ```

**d. Column:**
- **Definition:** The `Column` widget arranges its children in a vertical sequence.
- **Example:**
  ```dart
  Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: <Widget>[
      Text('Column 1'),
      SizedBox(height: 10),
      Text('Column 2'),
    ],
  )
  ```

**e. Image:**
- **Definition:** The `Image` widget displays an image from various sources such as assets, network, or memory.
- **Example:**
  ```dart
  Image.network(
    'https://example.com/image.png',
    width: 100,
    height: 100,
  )
  ```

**f. Combining Widgets:**
- **Example:** Combining multiple widgets to create a complex UI.
  ```dart
  Container(
    padding: EdgeInsets.all(10.0),
    margin: EdgeInsets.all(10.0),
    decoration: BoxDecoration(
      color: Colors.blue,
      borderRadius: BorderRadius.circular(10.0),
    ),
    child: Column(
      children: <Widget>[
        Text(
          'Hello, Flutter!',
          style: TextStyle(fontSize: 24, color: Colors.white),
        ),
        Image.network(
          'https://example.com/image.png',
          width: 100,
          height: 100,
        ),
      ],
    ),
  )
  ```

---

### **Conclusion**

In this session, we explored the basics of Flutter, focusing on understanding widgets, distinguishing between `StatelessWidget` and `StatefulWidget`, and learning about the widget tree and the `build` method. We also introduced essential widgets like `Container`, `Text`, `Row`, `Column`, and `Image`, which form the foundation of Flutter's UI components. Mastery of these concepts is crucial for building well-structured and efficient Flutter applications.
